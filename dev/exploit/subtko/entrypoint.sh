#!/bin/bash
set -eEo pipefail
trap '$UTILS/_stacktrace.sh "$?" "$BASH_SOURCE" "$BASH_COMMAND" "$LINENO"' ERR

update_resolvers(){
	# Get updated list of resolvers once a day
	if [ $(($(date +%s)-$(date +%s -r $RESOLVERS_FILE || echo 86401))) -gt 86400 ]; then
		$UTILS/_log.sh 'info' 'Downloading resolvers file'
		# Send to tmp file to avoid corrupting the file in case of curl errors
		tmp_resolvers_file=/tmp/adh-exploit-subtko-update-resolvers-tmp
		curl --no-progress-meter --fail https://raw.githubusercontent.com/trickest/resolvers/main/resolvers.txt > $tmp_resolvers_file
		# Replace resolvers file
		cp $tmp_resolvers_file $RESOLVERS_FILE
	fi
}

run_nuclei(){
	nuclei_input=$1
	nuclei_args=$2
	nuclei_output=/tmp/adh-exploit-subtko-run-nuclei-and-save-nuclei-output

	nuclei \
		-list $nuclei_input -output $nuclei_output -jsonl \
		-silent -no-stdin -resolvers $RESOLVERS_FILE \
		-concurrency 1 -rate-limit 10 -no-interactsh \
		$nuclei_args \
	> /dev/null

	if [ ! -s "$nuclei_output" ]; then
		$script_path/_log.sh 'info' 'Nothing was found'
	fi

	# Parse and print nuclei output in JSON Lines format according to Vuln schema
	cat $nuclei_output | while read line; do
		line_file=/tmp/adh-exploit-subtko-run-nuclei-and-save-nuclei-line && echo "$line" > $line_file # Save line to file so it can be printed on log
		$script_path/_log.sh 'debug' 'Parsing nuclei output' "output=$line_file"
		echo "$line" | jq -c '{
			name: ( .info.name + ": " + (."matched-at" | sub("^http(s){0,1}://"; "")) ),
			domain: { name: (."matched-at" | sub("^http(s){0,1}://"; "")) },
			title: .info.name,
			class: { name: "subtko" },
			description: .info.description,
			severity: .info.severity,
			references: .info.reference,
			evidence: { target: ."extracted-results"[0], request: .request, response: .response },
			foundBy: [ { name: "nuclei", type: "exploit" } ],
			updatedAt: .timestamp
		}' || $script_path/_log.sh 'error' 'Error while parsing nuclei output' "output=$line_file"
	done
}

run_nuclei_and_save(){
	input=$1
	args=$2

	result=/tmp/adh-exploit-subtko-run-nuclei-and-save-result
	run_nuclei "$input" "$args" > $result

	# Save vulns on database if output is not empty
	if [ -s "$result" ]; then
		$script_path/query_dgraph.sh -q "
			mutation {
				addVuln(input: $(jq -c -s $result), upsert: true){
					vuln { name }
				}
			}
		"
	fi
}

dangling_cname_scan(){
	input=$1

	initial_output=/tmp/adh-exploit-subtko-dangling-cname-scan-exploit-initial-output
	run_nuclei $input '-t dns/detect-dangling-cname.yaml' > $initial_output

	# Get unique list of domains from dangling cnames findings
	rootdomains=/tmp/adh-exploit-subtko-dangling-cname-scan-domains
	cat $initial_output | while read line; do
		$UTILS/_log.sh 'debug' 'Extracting CNAME from initial output' "jsonline=$line"
		cname=$(echo $line | jq -r '.evidence.target' | sed 's/\.$//')
		$UTILS/_log.sh 'info' 'Found CNAME with status NXDOMAIN' "cname=$cname"
		# Return rootdomain by leveraging the tld list file
		echo $cname | egrep -o "[^.]+\.($(xargs -a $UTILS/tld-list.txt | sed 's/ /|/g'))(\.[^.]+)?$"
	done > $rootdomains
	sort -u $rootdomains -o $rootdomains

	# For each rootdomain
	output=/tmp/adh-exploit-subtko-dangling-cname-scan-exploit-output
	cat $rootdomains | while read rootdomain; do
		# Check if is available to claim
		$UTILS/_log.sh 'info' 'Checking if rootdomain is available' "rootdomain=$rootdomain"
		if whois $rootdomain 2>/dev/null | grep -i 'no match\|not found' > /dev/null; then
			$UTILS/_log.sh 'info' 'Rootdomain is available' "rootdomain=$rootdomain"
			# Return all dangling cname findings from initial output that ends with this rootdomain
			jq -c "select(.evidence.target | test(\"$rootdomain(.)?$\"))" $initial_output
		else
			$UTILS/_log.sh 'info' 'Rootdomain is not available' "rootdomain=$rootdomain"
		fi
	done > $output

	# Save vulns on database if output is not empty
	if [ -s "$output" ]; then
		$UTILS/query_dgraph.sh -q "
			mutation {
				addVuln(input: $(jq -c -s $output), upsert: true){
					vuln { name }
				}
			}
		"
	fi
}

get_domains(){
	filter='not eq(Domain.skipScans, true)'
	extra_filter=$1
	if [ -n "$extra_filter" ]; then
		filter="$filter and $extra_filter"
	fi

	records=/tmp/adh-exploit-subtko-get-domains-records
	# Get CNAME values from 100 domains without the "lastExploit" field
	$UTILS/get_dnsrecords.sh -t CNAME -f "$filter and not has(Domain.lastExploit)" -a 'first: 100' > $records
	# If all domains have "lastExploit", get 100 oldests that are at least older than $DOMAIN_SCAN_COOLDOWN
	if [ ! -s "$records" ]; then
		$UTILS/get_dnsrecords.sh -t CNAME \
			-f "$filter and lt(Domain.lastExploit, \"$(date -Iseconds -d "-$DOMAIN_SCAN_COOLDOWN")\")" \
			-a 'first: 100, orderasc: Domain.lastExploit' \
		> $records
	fi

	if [ ! -s "$records" ]; then # Return if unable to get records
		return
	fi

	# Get domains from cname records
	$UTILS/_log.sh 'debug' 'Parsing records' "records=$(cat $records)"
	domains=/tmp/adh-exploit-subtko-get-domains-domains
	awk '{print $1}' $records | sort -u > $domains

	$UTILS/_log.sh 'info' 'Updating lastExploit field' "domains=$(cat $domains)"
	$UTILS/save_domains.sh -f <(cat $domains | sed '1i name,lastExploit' | sed "s/$/,$(date -Iseconds)/") > /dev/null

	# Print domains
	cat $domains
}

while true; do
	$UTILS/op_start.sh

	update_resolvers

	domains=/tmp/adh-exploit-subtko-domains
	get_domains > $domains

	if [ ! -s "$domains" ]; then
		$UTILS/_log.sh 'info' "No domain to scan. Trying again in 10 seconds"
		sleep 10
		continue
	fi

	$UTILS/_log.sh 'info' 'Running: Nuclei (Dangling CNAME - Generic)'
	dangling_cname_scan $domains

	$UTILS/_log.sh 'info' 'Running: Nuclei (Dangling CNAME - Cloud Providers)'
	run_nuclei_and_save $domains '-templates dns/elasticbeanstalk-takeover.yaml,dns/azure-takeover-detection.yaml'

	$UTILS/_log.sh 'info' 'Running: Nuclei (HTTP Based Takeovers)'
	run_nuclei_and_save $domains '-templates http/takeovers'

	$UTILS/op_end.sh
done
